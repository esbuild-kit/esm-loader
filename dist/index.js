import l from"path";import{fileURLToPath as w,pathToFileURL as v}from"url";import{installSourceMapSupport as U,compareNodeVersion as p,resolveTsPath as D,transform as T,transformDynamicImport as S}from"@esbuild-kit/core-utils";import{parseTsconfig as I,getTsconfig as M,createFilesMatcher as W,createPathsMatcher as A}from"get-tsconfig";import k from"fs";const d=new Map;async function L(t){if(d.has(t))return d.get(t);if(!await k.promises.access(t).then(()=>!0,()=>!1)){d.set(t,void 0);return}const r=await k.promises.readFile(t,"utf8");try{const e=JSON.parse(r);return d.set(t,e),e}catch{throw new Error(`Error parsing: ${t}`)}}async function J(t){let s=new URL("package.json",t);for(;!s.pathname.endsWith("/node_modules/package.json");){const r=w(s),e=await L(r);if(e)return e;const o=s;if(s=new URL("../package.json",s),s.pathname===o.pathname)break}}async function b(t){var s;const r=await J(t);return(s=r==null?void 0:r.type)!=null?s:"commonjs"}const f=U(),u=process.env.ESBK_TSCONFIG_PATH?{path:l.resolve(process.env.ESBK_TSCONFIG_PATH),config:I(process.env.ESBK_TSCONFIG_PATH)}:M(),N=u&&W(u),R=u&&A(u),_="file://",h=/\.([cm]?ts|[tj]sx)$/,x=t=>{const s=l.extname(t);if(s===".json")return"json";if(s===".mjs"||s===".mts")return"module";if(s===".cjs"||s===".cts")return"commonjs"},O=t=>{const s=x(t);if(s)return s;if(h.test(t))return b(t)},C=p([20,0,0])>=0;let y=process.send?process.send.bind(process):void 0,E;const K=({port:t})=>(E=t,y=t.postMessage.bind(t),`
	const require = getBuiltin('module').createRequire("${import.meta.url}");
	require('@esbuild-kit/core-utils').installSourceMapSupport(port);
	if (process.send) {
		port.addListener('message', (message) => {
			if (message.type === 'dependency') {
				process.send(message);
			}
		});
	}
	port.unref(); // Allows process to exit without waiting for port to close
	`),$=C?K:void 0,B=[".js",".json",".ts",".tsx",".jsx"];async function P(t,s,r){let e;for(const o of B)try{return await g(t+o,s,r,!0)}catch(a){if(e===void 0&&a instanceof Error){const{message:n}=a;a.message=a.message.replace(`${o}'`,"'"),a.stack=a.stack.replace(n,a.message),e=a}}throw e}async function j(t,s,r){const e=t.endsWith("/"),o=e?"index":"/index";try{return await P(t+o,s,r)}catch(a){if(!e)try{return await P(t,s,r)}catch{}const n=a,{message:c}=n;throw n.message=n.message.replace(`${o.replace("/",l.sep)}'`,"'"),n.stack=n.stack.replace(c,n.message),n}}const G=/^\.{0,2}\//,H=p([14,13,1])>=0||p([12,20,0])>=0,g=async function(t,s,r,e){var o;if(!H&&t.startsWith("node:")&&(t=t.slice(5)),t.endsWith("/"))return await j(t,s,r);const a=t.startsWith(_)||G.test(t);if(R&&!a&&!((o=s.parentURL)!=null&&o.includes("/node_modules/"))){const c=R(t);for(const i of c)try{return await g(v(i).toString(),s,r)}catch{}}if(h.test(s.parentURL)){const c=D(t);if(c)try{return await g(c,s,r,!0)}catch(i){const{code:m}=i;if(m!=="ERR_MODULE_NOT_FOUND"&&m!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw i}}let n;try{n=await r(t,s)}catch(c){if(c instanceof Error&&!e){const{code:i}=c;if(i==="ERR_UNSUPPORTED_DIR_IMPORT")try{return await j(t,s,r)}catch(m){if(m.code!=="ERR_PACKAGE_IMPORT_NOT_DEFINED")throw m}if(i==="ERR_MODULE_NOT_FOUND")try{return await P(t,s,r)}catch{}}throw c}return!n.format&&n.url.startsWith(_)&&(n.format=await O(n.url)),n},q=async function(t,s,r){var e;y&&y({type:"dependency",path:t}),t.endsWith(".json")&&(s.importAssertions||(s.importAssertions={}),s.importAssertions.type="json");const o=await r(t,s);if(!o.source)return o;const a=t.startsWith("file://")?w(t):t,n=o.source.toString();if(o.format==="json"||h.test(t)){const c=await T(n,a,{tsconfigRaw:(e=N)==null?void 0:e(a)});return{format:"module",source:f(c,t,E)}}if(o.format==="module"){const c=S(a,n);c&&(o.source=f(c,t,E))}return o},X=async function(t,s,r){if(t.endsWith(".json"))return{format:"module"};try{return await r(t,s,r)}catch(e){if(e.code==="ERR_UNKNOWN_FILE_EXTENSION"&&t.startsWith(_)){const o=await O(t);if(o)return{format:o}}throw e}},V=async function(t,s,r){var e;const{url:o}=s,a=o.startsWith("file://")?w(o):o;if(process.send&&process.send({type:"dependency",path:o}),o.endsWith(".json")||h.test(o)){const c=await T(t.toString(),a,{tsconfigRaw:(e=N)==null?void 0:e(a)});return{source:f(c,o)}}const n=await r(t,s,r);if(s.format==="module"){const c=S(a,n.source.toString());c&&(n.source=f(c,o))}return n},F=p([16,12,0])<0,z=F?X:void 0,Q=F?V:void 0;export{z as getFormat,$ as globalPreload,q as load,g as resolve,Q as transformSource};
